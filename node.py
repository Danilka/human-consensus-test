from __future__ import annotations
import logging
from typing import List, Union
from block import Block
from candidate import Candidate
from message import Message
from transport import Transport


class Node:

    # ID of the node.
    node_id: int

    # Pointer to the list of all nodes.
    nodes: List[Node]

    # Current chain.
    chain: List[Block]

    # Dict of candidate blocks and their proofs.
    candidates: dict
    """
        {
            block_id: Candidate,
            ...
        }
    """

    # Pointer to the current active candidate.
    active_candidate: Union[Candidate, None]

    # Link to a global Transport object
    transport: Transport

    # Should we keep extra messages after a proof was achieved.
    keep_excessive_messages: bool

    def __init__(
        self,
        nodes: List[Node],
        node_id: int,
        transport: Transport,
        chain: Union[List, None] = None,
        keep_excessive_messages: bool = False,
    ):
        """Constructor"""
        # Assignment
        self.node_id = node_id
        self.chain = chain if chain else []
        self.candidates = {}
        self.active_candidate = None
        self.transport = transport
        nodes.append(self)
        self.nodes = nodes
        self.keep_excessive_messages = keep_excessive_messages

    def get_next_block_id(self) -> int:
        return len(self.chain) + 1

    def get_next_block_master_id(self) -> int:
        # Get next block master node ID
        # This assumes that nodes never change after initiating the group.
        return self.get_next_block_id() % len(self.nodes)

    def verify_block(self, block: Block) -> bool:
        # Verifies if a block is real.
        if block.block_id % len(self.nodes) == block.node_id:
            return True
        return False

    def enough_approves(self, message_chain=None) -> bool:
        """
        Check if we have enough approves for the current block_candidate.
        :return: True - there is enough approves, False - not enough approves.
        """
        if message_chain is None:
            if len(self.active_candidate.messages_approve) > (len(self.nodes) - 1) / 2.0:
                return True
            return False
        else:
            if len(message_chain) > (len(self.nodes) - 1) / 2.0:
                return True
            return False

    def enough_votes(self, message_chain=None) -> bool:
        """
        Check if we have enough votes for the current block_candidate.
        :return: True - there is enough votes, False - not enough votes.
        """
        if message_chain is None:
            return len(self.active_candidate.messages_vote) > len(self.nodes) / 2.0
        else:
            return len(message_chain) > len(self.nodes) / 2.0

    def enough_vote_status_updates(self) -> bool:
        """
        Check if we have enough vote status updates in the current candidate to try forging a new block.
        :return: True - enough votes, False, not enough votes.
        """
        return len(self.active_candidate.vote_status_updates) > len(self.nodes) / 2.0

    def gen_commit(self) -> bool:
        if self.node_id != self.get_next_block_master_id():
            # logging.error("Node #{} tried to generate a commit, while it should have been generated by {}".format(
            #     self.node_id,
            #     self.get_next_block_master_id(),
            # ))
            return False

        # Gen new block.
        block = Block(
            block_id=self.get_next_block_id(),
            node_id=self.node_id,
        )

        self.candidates[block.block_id] = Candidate(block)
        self.active_candidate = self.candidates[block.block_id]

        # Gen broadcast message.
        message = Message(
            node_id=self.node_id,
            message_type=Message.TYPE_COMMIT,
            block=block,
        )

        self.broadcast(message)
        return True

    def try_forging_candidate_block(self) -> bool:
        """
        Attempt to forge a candidate block and send vote status update.
        :return: True - Block is forged, False - block is not forged.
        """

        # Block validation
        if not self.active_candidate:
            logging.info("N{} Unsuccessful forge attempt, there is no candidate block.".format(self.node_id))
            return False

        # Check if we have enough vote status updates.
        if not self.enough_vote_status_updates():
            return False

        # Just in case validating votes, but this should pass if the vote status update has passed.
        if not self.enough_votes():
            return False

        # Log successful forge attempt.
        logging.info("N{} B{} is forged.".format(self.node_id, self.active_candidate.block_id))

        # Forge the block and add it to the chain.
        self.chain.append(self.active_candidate.block)
        self.active_candidate.forged = True
        self.active_candidate = None

        # Moved to self.run() method.
        # # Try generating the next block if we are the appropriate node.
        # self.gen_commit()

        return True

    def broadcast(self, message: Message, exclude_node_ids: Union[None, List[int]] = None):
        """ Send message to everyone. """
        if isinstance(exclude_node_ids, list):
            exclude_node_ids.append(self.node_id)
        else:
            exclude_node_ids = [self.node_id]

        for i in range(len(self.nodes)):
            # Skipp sending messages excluded list.
            if i in exclude_node_ids:
                continue
            self.transport.send(message, to_id=i)

    def send_approve_once(self):
        """Send approval message to everyone once."""
        if Candidate.ACTION_APPROVE in self.active_candidate.actions_taken:
            return False

        # Save the action we are taking.
        self.active_candidate.actions_taken.add(Candidate.ACTION_APPROVE)

        # Prepare the message.
        message_out = Message(
            node_id=self.node_id,
            message_type=Message.TYPE_APPROVE,
            block=self.active_candidate.block,
        )

        # Save approve message into our own log as well.
        self.active_candidate.messages_approve[self.node_id] = message_out
        self.broadcast(message_out)
        return True

    def send_vote_once(self):
        """Send vote message to everyone once."""
        if self.active_candidate.check_action(Candidate.ACTION_VOTE):
            return False

        # Check if we have enough approve votes, we send a status update.
        if not self.enough_approves():
            return False

        # Save the action we are taking.
        self.active_candidate.take_action(Candidate.ACTION_VOTE)

        # Save our own vote.
        self.active_candidate.messages_vote[self.node_id] = self.active_candidate.messages_approve

        # Prepare the message.
        message_out = Message(
            node_id=self.node_id,
            block=self.active_candidate.block,
            message_type=Message.TYPE_VOTE,
            # TODO: This should have a separate diff for each node with only messages that they need to reach approval.
            # messages_chain={**self.messages_vote, **{self.node_id: self.messages_approve}}
            messages_chain=self.active_candidate.messages_vote[self.node_id],
        )

        # Send.
        self.broadcast(message_out)
        return True

    def send_approve_status_update_once(self) -> bool:
        """
        Send approve status update once if we have enough approves.
        :return: True - update was sent. False - update was not sent.
        """
        if self.active_candidate.check_action(Candidate.ACTION_APPROVE_STATUS_UPDATE):
            return False

        if not self.enough_approves():
            return False

        self.active_candidate.take_action(Candidate.ACTION_APPROVE_STATUS_UPDATE)

        message_out = Message(
            node_id=self.node_id,
            block=self.active_candidate.block,
            message_type=Message.TYPE_APPROVE_STATUS_UPDATE,
            # TODO: This should have a separate diff for each node with only messages
            # that they need to reach approval.
            messages_chain=self.active_candidate.messages_approve,
        )
        self.broadcast(message_out)

        return True

    def send_vote_status_update_once(self) -> bool:
        """
        Send vote status update once if we have enough votes.
        :return: True - update was sent. False - update was not sent.
        """

        if self.active_candidate.check_action(Candidate.ACTION_VOTE_STATUS_UPDATE):
            return False

        if not self.enough_votes():
            return False

        # Prepare the message.
        message_out = Message(
            node_id=self.node_id,
            block=self.active_candidate.block,
            message_type=Message.TYPE_VOTE_STATUS_UPDATE,
            # TODO: This should have a separate diff for each node with only messages
            # that they need to reach votes.
            messages_chain=self.active_candidate.messages_vote,
        )

        # Set a flag that we have sent this update out.
        self.active_candidate.take_action(Candidate.ACTION_VOTE_STATUS_UPDATE)

        # Increment the vote_status update counter with our own info.
        self.active_candidate.vote_status_updates.add(self.node_id)

        # Broadcast the message.
        self.broadcast(message_out)

        return True

    def receive_commit(self, message_in: Message) -> bool:
        """Receive a commit message."""
        # This logic is already handled by block validation in self.receive()
        return True

    def receive_approve(self, message_in: Message) -> bool:
        """Receive an approve message."""

        # If we already voted, we do not need extra approves.
        if not self.keep_excessive_messages and self.active_candidate.check_action(Candidate.ACTION_VOTE):
            return False

        if message_in.node_id in self.active_candidate.messages_approve:
            # We already have this message, so we disregard it.
            logging.debug(
                "N{} received an approve from N{}, but already had it.".format(
                    self.node_id,
                    message_in.node_id,
                )
            )
            return True

        self.active_candidate.messages_approve[message_in.node_id] = message_in

        # Send approve status update if we need to.
        self.send_approve_status_update_once()

        # We have enough approves, now we also send out our vote.
        self.send_vote_once()

        return True

    def receive_approve_status_update(self, message_in: Message) -> bool:
        """Receive an approve status update message."""
        # Verify message chain.
        for _, message_in_chain in message_in.messages_chain.items():
            if not self.verify_block(message_in_chain.block):
                # Got a message with a wrong block.
                logging.error("N{} received an approve status update from N{} with a wrong block".format(
                    self.node_id,
                    message_in.node_id,
                ))
                return False
        if not self.enough_approves(message_in.messages_chain):
            # This means that there is not enough votes for approval.
            logging.error(
                "N{} received an approve status update from N{} with not enough votes in it".format(
                    self.node_id,
                    message_in.node_id,
                )
            )
            return False

        if self.active_candidate and self.active_candidate.block != message_in.block:
            # This means that my block is different from the one that is being approved.
            # TODO: We need to find the difference and update our chain up to this block.
            logging.error(
                "N{} received an approve status update from N{} with a block ({}) "
                "that differs from my candidate ({}).".format(
                    self.node_id,
                    message_in.node_id,
                    message_in.block,
                    self.active_candidate.block,
                ))
            return False

        ### At this point the blocks match and the messages chan from that node is correct. ###

        # Update our messages_approve with the new info from the message.
        if not self.active_candidate.check_action(Candidate.ACTION_VOTE) or self.keep_excessive_messages:
            self.active_candidate.messages_approve.update(message_in.messages_chain)

        # Save the whole approve message chain for that node.
        # TODO: Comment this out as the other node's approval chain could still fill up and be updated.
        # self.messages_vote[message_in.node_id] = message_in.messages_chain

        # We have enough approves, now we also send out our vote.
        self.send_vote_once()

        return True

    def receive_vote(self, message_in: Message) -> bool:
        """Receive a vote message."""

        # If we already have this message, so we disregard it.
        if message_in.node_id in self.active_candidate.messages_vote:
            logging.info(
                "N{} received a vote from N{}, but already had it.".format(
                    self.node_id,
                    message_in.node_id,
                )
            )
            return False

        # Save the vote.
        self.active_candidate.messages_vote[message_in.node_id] = message_in.messages_chain

        # Try sending vote status update if we have enough votes.
        self.send_vote_status_update_once()

        # Try forging the candidate block.
        self.try_forging_candidate_block()

        return True

    def receive_vote_status_update(self, message_in: Message) -> bool:
        """Receive a vote status update message."""
        # If we are getting this, it means that the block is forged by others, but not us.
        # So we update the info and try to forge ourselves.

        # Update our vote messages chain.
        for node_id_in in message_in.messages_chain.keys():
            if node_id_in not in self.active_candidate.messages_vote:
                self.active_candidate.messages_vote[node_id_in] = message_in.messages_chain[node_id_in]
            # TODO: We do not need to update chains for the votes that we already have. They should be the exact same.
            else:
                if self.active_candidate.messages_vote[node_id_in] != message_in.messages_chain[node_id_in]:
                    logging.debug(
                        "N{} received a vote status update from N{}. "
                        "In the payload there was a vote proof for N{}'s vote. "
                        "N{} had a local copy that differs from the received proof.\n"
                        "Local proof: {}\n"
                        "Received proof: {}".format(
                            self.node_id,
                            message_in.node_id,
                            node_id_in,
                            self.node_id,
                            self.active_candidate.messages_vote[node_id_in],
                            message_in.messages_chain[node_id_in],
                        )
                    )

        # Increment the vote_status update counter with the info we got.
        self.active_candidate.vote_status_updates.add(message_in.node_id)

        # The rest, in theory, should always pass.
        # Since we just got a vote status update that has complete info for this block.

        # Send vote status update if we need to.
        self.send_vote_status_update_once()

        # Try forging the candidate block.
        self.try_forging_candidate_block()

        return True

    def receive(self, message_in: Message) -> bool:
        """Receive a message from another node."""

        # Check if the message has a block.
        if not message_in.block:
            logging.error(
                "N{} received a message from N{} and discarded because there is no block attached.".format(
                    self.node_id,
                    message_in.node_id,
                )
            )
            return False

        # First we verify sent block in the message. If it's bad, we disregard the message.
        if not self.verify_block(message_in.block):
            logging.error(
                "N{} received a message from N{} and discarded it because the block is invalid.".format(
                    self.node_id,
                    message_in.node_id
                )
            )
            return False

        # Check if the block has already been forged.
        if message_in.block in self.chain:
            # TODO: We should probably send the proof message to the requesting node, so it can forge the block as well.
            logging.debug(
                "N{} received a message from N{} and discarded it because this block is already forged.".format(
                    self.node_id,
                    message_in.node_id,
                )
            )
            return False

        # Save new block as a candidate if we do not already have it.
        if message_in.block.block_id not in self.candidates:
            self.candidates[message_in.block.block_id] = Candidate(block=message_in.block)
            # Set current active candidate.
            self.active_candidate = self.candidates[message_in.block.block_id]
            # Since we just got a new block and verified it to be good, we broadcast an approval for it.
            self.send_approve_once()
        elif self.candidates and sorted(self.candidates.keys(), reverse=True)[0] == message_in.block.block_id:
            # Set current active candidate to the last block.
            self.active_candidate = self.candidates[message_in.block.block_id]
        else:
            # Drop the message processing if we received a message on an old block.
            return False

        # COMMIT
        if message_in.message_type == Message.TYPE_COMMIT:
            # Commit message is fully handled by the block validation. There is no need to do anything else really.
            return self.receive_commit(message_in)

        # APPROVE
        # TODO
        elif message_in.message_type == Message.TYPE_APPROVE:
            return self.receive_approve(message_in)

        # APPROVE_STATUS_UPDATE
        # TODO
        elif message_in.message_type == Message.TYPE_APPROVE_STATUS_UPDATE:
            return self.receive_approve_status_update(message_in)

        # VOTE
        # TODO
        elif message_in.message_type == Message.TYPE_VOTE:
            return self.receive_vote(message_in)

        # VOTE_STATUS_UPDATE
        # TODO
        elif message_in.message_type == Message.TYPE_VOTE_STATUS_UPDATE:
            return self.receive_vote_status_update(message_in)

    def run(self, message: Union[Message, None] = None):
        """
        Main loop method.
        :param message: Message object to be received by this node.
        :return:
        """

        # Process the message if we got one.
        if message:
            self.receive(message_in=message)

        # Try generating the block if we are the appropriate node for it.
        if not self.active_candidate:
            self.gen_commit()
